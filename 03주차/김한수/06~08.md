# 6~8

- [6~8](#68)
- [06. 동시성](#06-동시성)
  - [Topic 33 시간적 결합 깨트리기](#topic-33-시간적-결합-깨트리기)
  - [Topic 34 공유 상태는 틀린 상태](#topic-34-공유-상태는-틀린-상태)
  - [Topic 35 액터와 프로세스](#topic-35-액터와-프로세스)
  - [Topic 36 칠판](#topic-36-칠판)
- [07. 코딩하는 동안](#07-코딩하는-동안)
  - [Topic 37 파충류의 뇌에 귀 기울이기](#topic-37-파충류의-뇌에-귀-기울이기)
  - [Topic 38 우연에 맡기는 프로그래밍](#topic-38-우연에-맡기는-프로그래밍)
    - [의도적으로 프로그래밍하기](#의도적으로-프로그래밍하기)
  - [Topic 39 알고리즘의 속도](#topic-39-알고리즘의-속도)
  - [Topic 40 리팩터링](#topic-40-리팩터링)
  - [Topic 41 테스트로 코딩하기](#topic-41-테스트로-코딩하기)
  - [Topic 42 속성 기반 테스트](#topic-42-속성-기반-테스트)
  - [Topic 43 바깥에서는 안전에 주의하라](#topic-43-바깥에서는-안전에-주의하라)
  - [Topic 44 이름 짓기](#topic-44-이름-짓기)
    - [컴퓨터 과학에는 어려운 문제가 딱 두 개 있다. **캐시 무효와와 이름 짓기 그리고 하나 차이(off-by-one) 오류**](#컴퓨터-과학에는-어려운-문제가-딱-두-개-있다-캐시-무효와와-이름-짓기-그리고-하나-차이off-by-one-오류)
- [08. 프로젝트 전에](#08-프로젝트-전에)
  - [Topic 45 요구 사항의 구렁텅이](#topic-45-요구-사항의-구렁텅이)
  - [Topic 46 불가능한 퍼즐 풀기](#topic-46-불가능한-퍼즐-풀기)
  - [Topic 47 함께 일하기](#topic-47-함께-일하기)
  - [Topic 48 애자일의 핵심](#topic-48-애자일의-핵심)
    - [애자일 프로세스라는 것은 있을 수 없다](#애자일-프로세스라는-것은-있을-수-없다)
    - [**애자일하게 일하는 방법 제안**](#애자일하게-일하는-방법-제안)


# 06. 동시성

`동시성(concurrency)`은 둘 이상의 코드 조각이 실행될 때 동시에 실행 중인 것처럼 행동하는 것이다.

그리고 `병렬성(parallelism)` 이란 **실제로** 동시에 실행되는 것이다.

**모든 일에는 동시성이 있다.**

- 시스템의 규모가 어느 정도를 넘어가면 동시성은 필수적이다.
- 이 장에서는 동시성과 병렬성을 살펴본다.

## Topic 33 시간적 결합 깨트리기

- `시간적 결합`이란 말 그대로 시간에 관한 이야기이다.
  - e.g. 메서드 A는 언제나 메서드 B보다 먼저 호출해야 한다
  - **이런 결합을 깨트릴 수 있는지 확인하고 깨트려라**
- **작업 흐름 분석으로 동시성을 개선하라**

## Topic 34 공유 상태는 틀린 상태

- 공유 상태는 틀린 상태이다.
  - 상태가 공유되면 동시성 문제가 발생한다. 이를 해결해야한다.
- 동시성 문제 해결하기
  - 결국 한 번에 한 명만 데이터를 수정할 수 있도록 lock 개념을 활용해야한다.
  - e.g. `세마포어` : 단순히 한번에 한 사람만 가질 수 있는 무언가, 상호 배제 방법 등
  - 트랜잭션 등등..
- 수정 가능한 리소스를 공유하는 애플리케이션 코드 어디에서나 동시성 문제가 발생할 수 있고
  - **보통 불규칙한 실패는 동시성 문제인 경우가 많다.**

## Topic 35 액터와 프로세스

- 액터(actor)와 프로세스를 사용하면 흥미로운 방식으로 동시성을 구현할 수 있다.
- 그리고 공유 메모리 접근을 동기화하느라 고생할 필요도 없다.
- `액터`
  - 자신만의 비공개 지역 상태를 가진 독립적인 가상 처리 장치.
  - 단순히 액터에 메시지를 보내주면 액터가 메시지를 확인하고 **한 번에 하나씩만** 처리하는 방식. message queue와 유사함
  - 모든 메시지가 일방향인 특징이 있음. 답장을 받고 싶다면 답장받을 정보를 메시지에 포함해야함.

## Topic 36 칠판

- 칠판을 예시로 프로세스를 제어하는 비유에 대한 이야기
- 칠판에 문제를 적었다고 쳤을 때
  - 칠판에 문제를 풀기 위해 단서들을 붙이는 각 사람들은 독립된 프로세스, 에이전트, 액터 등과 같다.
    - 이들은 서로의 존재를 알 필요가 없이 찰판만 보며 새로운 정보를 얻고 자기가 발견한 사실을 칠판에 덧붙인다.
  - 누군가는 칠판에 무언가를 적고 누군가는 지워낸다. 그리고 칠판에 적힌 내용들을 조합하거나 처리할 수도 있다.
  - **결국 칠판은 사람들이 서서히 결론에 도달하도록 돕는다.**
- **이 칠판과 같은 장치로 작업 흐름을 조율하라**

# 07. 코딩하는 동안

## Topic 37 파충류의 뇌에 귀 기울이기

- 우리는 코드가 보내는 피드백을 우리 안에 파충류의 뇌로 본능적으로 느낄 수 있다.
  - **내면의 파충류에게 귀 기울여라**
- **의외로 직감에 귀 기울이는 방법은 계속 갈고닦아야 할 중요한 기술이다.**
  - 작업하다가 이상한 느낌이 든다면 잠깐 멈춰서 그 느낌을 분석하라
  - 여러분의 목소리에 귀를 기울여 주는 환경에 있다면 적극적으로 표현하고 탐험하라.

## Topic 38 우연에 맡기는 프로그래밍

**우리는 우연에 맡기는 프로그래밍, 곧 행운과 우연한 성공에 의존하는 프로그래밍을 하지 않아야 한다.**

- 대신 `의도적으로 프로그래밍` 해야 한다.
- **가정하지 말고 증명하라.**
  - 확고한 사실에 근거하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 된다

### 의도적으로 프로그래밍하기

- **언제나 여러분이 지금 무엇을 하고 있는지 알아야 한다.**
- **더 경험이 적은 프로그래머에게 코드를 상세히 설명할 수 있어야한다.**
  - 그렇지 않다면 아마 우연에 기대고 있는 것일 터이다.
- **자신도 잘 모르는 코드를 만들지 말라.**
  - 우연의 함정에 빠질 가능성이 높다.
- **계획을 세우고 그것을 바탕으로 진행하라.**
- **신뢰할 수 있는 것에만 기대라. 가정에 의존하지 말라.**
  - 무언가를 신뢰할 수 있을지 판단하기 어렵다면 일단 최악의 상황을 가정하라.
- **가정을 기록으로 남겨라.**
  - 이는 가정을 명확히 하는 데 도움이 되고 다른 사람과 소통하는 데에도 도움이 돤다.
- **코드뿐만 아니라 여러분이 세운 가정도 테스트해 보야아 한다.**
  - 어떤 일이든 추측만 하지 말고 실제로 시험해 보라.
  - 여러분의 가정을 시험할 수 있는 단정문을 작성하라
- **노력을 기울일 대상의 우선순위를 정하라**
  - 중요한 것에 먼저 시간을 투자하라.
  - 중요한 부분이 가장 어려운 부분이기도 한 경우가 많다.
  - 기본이나 기반 구조가 제대로 되어 있지 않다면 현란한 부가 기능도 다 부질없다.
- **과거의 노예가 되지 말라.**
  - 기존 코드가 앞으로 짤 코드를 지배하지 못하도록 하라.
  - **언제나 리팩토링할 자세가 되어야 한다.**

## Topic 39 알고리즘의 속도

- 사용하는 알고리즘의 차수를 추정하라 이런 추정이 결정적인 경우도 많다.
- **성급한 최적화를 조심하라**

## Topic 40 리팩터링

- 리팩터링은 언제하는가?
  - **무엇이든 잘못되었다는 생각이 들 때 주저하지 말고 변경하라**
  - 언제나 바로 지금이 최적기다.
- 일찍 리팩터링하고, 자주 리팩터링하라.
- 리팩터링은 어떻게 하는가?
  - 리팩터링의 본질은 재설계
  - 리팩터링과 기능 추가를 동시에 하지 말라.
  - 리팩터링을 시작하기 전 든든한 테스트가 있는지 먼저 확ㅇ니하라
  - 단계를 작게 나누어서 신중하게 작업하라

## Topic 41 테스트로 코딩하기

- 테스트는 버그를 찾기 위한 것이 아니다.
- 테스트가 코드의 첫 번째 사용자다.
  - **테스트는 우리의 코딩을 인도하는 필수 피드백이다**
  - 이것이 테스트가 주는 가장 큰 이득일지 모른다.
- 테스트할 수 있도록 설계하라
  - 테스트하기 좋게 만들면 결합도도 낮아진다
- 테스트 문화를 만들어라
  - 여러분의 소프트웨어를 테스트하지 않으면 사용자가 테스트하게 된다.

## Topic 42 속성 기반 테스트

- 코드에 존재하는 계약과 불변식을 뭉뚱그려서 `속성(property)` 이라고 부른다.
- 코드에서 속성을 찾아내서 테스트 자동화에 사용할 수 있는데, 이것을 `속성 기반 테스트`라 한다.
  - 속성기반 테스트는 여러 가지 다른 수행 결과와 상관없이 문제가 발생하는 상황에 집중할 수 있게 해주고
  - 단위 테스트가 회귀 테스트 역할을 한다

## Topic 43 바깥에서는 안전에 주의하라

- **보안을 신경써라**
  - 공격 표면을 최소화
  - 최소 권한 원칙
  - 안전한 기본값
  - 민감 정보를 암호화
  - 보안 업데이트 적용 (최신화)

## Topic 44 이름 짓기

- **이름을 잘 지어라**
  - 프로그래밍에서는 이름이 **모든 것**이다.
- 이름은 여러분의 의도와 믿음을 잔뜩 드러내기 때문에 아주아주 중요하다
- 여러분이 표현하고 싶은 것을 더 명확하게 다듬기 위해 끊임없이 노력해야 한다.
  - 이렇게 명확하게 다듬는 작업이 여러분이 코드를 작성할 때 코드를 더 잘 이해할 수 있도록 도울 것이다
  - **하지만 모든 이름이 문학상 후보에 올라야 하는 것은 아니다**

### 컴퓨터 과학에는 어려운 문제가 딱 두 개 있다. **캐시 무효와와 이름 짓기 그리고 하나 차이(off-by-one) 오류**

- **문화를 존중하라**
  - 컴퓨터 입문용 교재는 i, j, k 같은 한 글자 변수명을 절대 사용하지 말라고 강조하지만 이건 각 프로그래밍 언어나 환경의 문화에 달린 것이다.
  - C 언어 에서는 s는 문자열을 의미하는 관습도 있다.
- **일관성**
  - 이름의 일관성을 유지하라
  - 모두가 그 단어를 사용하도록 하여 일관성을 유지하고
  - 커뮤니케이션 비용을 덤으로 줄여라
- **이름 바꾸기는 더 어렵다**
  - **이름을 잘 지어라. 필요하다면 이름을 바꿔라**
  - 잘못된 이름을 바꿀 수 없는 상황이라면 더 큰 문제가 있는 것이다
  - 그 문제를 고치고나서 잘못된 이름을 바꾸고 이름을 바꾸기 쉽게 만들고 자주 이름을 바꿔라

# 08. 프로젝트 전에

## Topic 45 요구 사항의 구렁텅이

> **‘완성이라는 것은 더 이상 더할 것이 없을 때가 아니라, 더 이상 뺄 것이 없을 때 달성되는 것이다.’**
> **앙투안 드 생텍쥐페리**


- **자신이 뭘 원하는지 정확히 아는 사람은 아무도 없다**
  - 요구사항이 땅 위에 놓여 있는 경우는 드물다. 보통은 가정과 오해, 정치의 지층 속 깊숙이 묻혀있다. 심지어 아예 존재하지 않을 때도 있다.
  - 이걸 파해쳐야한다.
  - **프로그래머의 일은 사람들이 자신이 원하는 바를 깨닫도록 돕는 것이다.**
- **요구 사항은 과정이다**
  - 요구 사항은 피드백을 반복하며 알게 된다.
  - **피드백을 짧은 주기로 반복해서 받아라**
- **의뢰인의 입장에서 보라**
  - **사용자처럼 생각하기 위해 사용자와 함께 일하라**
- **요구 사항 대 정책**
  - 인증 정책을 예로 들면 보통 요구사항은 코드를 수정해야하고
  - 정책은 코딩없이 일부 데이터 수정만으로 바뀔 수 있다
  - **정책은 메타데이터다**
    - 정책은 시스템의 메타데이터만 업데이트하면 바로 반영되도록 잘 분리된 시스템을 만들어라

## Topic 46 불가능한 퍼즐 풀기

- 프로젝트 진행 도중 때때로 정말 어려운 퍼즐을 붙잡고 씰므할 일이 생길 것이다.
  - 어쩌면 불가능해 보일지도 모르겠다. **하지만 보이는 것만큼 실제로도 그렇게 어려울까?**
  - 제약 조건이 사실은 전혀 제약 조건이 아닐 수도 있따. 많은 소프트웨어 문제가 이런 속임수 같은 것일지도 모른다.
- **생각의 틀을 벗어나지 말고, 틀을 찾아라.**
  - **이게 진짜 제약을 찾는 일이다. 그리고 그 속에서 주어진 자유도를 파악하라.**
- **자신만의 방법에서 빠져나오라**
  - 어떤 때는 문제가 생각보다 훨씬 어려워 보이기도 하고, 접근 방법을 잘못 선택했다는 느낌이 들 것이다.
  - 이 불가능한 문제 때문에 일정이 늦어지고 있거나, 심지어 시스템을 작동하게 만드는 일 자체를 포기하고 있을지도 모르겠다.
  - **그 때가 잠시 딴짓하기 딱 좋은 시간이다. 이렇게 머리가 복잡할 때는 딴짓을 하고 일을 잠시 미뤄라. 산책 등등**
  - **딴 짓을 한 사람이 의식적으로 노력한 사람보다 복잡한 문제 해결 과제를 더 잘 해내는 경향이 있다.**
- **행운은 준비된 사람에게 찾아온다**
  - “유레카!”의 순간을 경험하려면 당신의 뇌이 무의식 영역에 원료를 많이 주입해야 한다. 문제 해결에 필요한 원료는 바로 해답에 도움이 될 수 있는 경험이다.
  - 뇌에 경험을 주입하는 가장 좋은 방법은 엔지니어링 일지를 활용하는 등 무엇이 잘되고 잘안되는지 피드백을 주는 것이다.

## Topic 47 함께 일하기

- `함께 일하기`는 그저 질문하고, 토론하고 메모를 하는 것이 아니라, 실제로 코딩을 하는 와중에 질문을 하고 토론을 하는 것이다.
- **짝 프로그래밍**
  - 개발자 한 명은 키보드를 조작하지만 다른 한 명은 하지 않는다
  - 서로의 감시 + 역할 분배를 통해 결과적으로 소프트웨어의 품질이 좋아짐
- **몹 프로그래밍**
  - 셋 이상의 사람이 참여하는 짝 프로그래밍의 확장판
  - 비개발 직군도 쉽게 끌어들일 수 있음
  - **실시간 코딩을 곁들인 밀접한 협업**
- **여기서 중요한 건 절대 코드에 혼자 들어가지 말라.**

## Topic 48 애자일의 핵심

- **애자일은 “기민하다” 라는 뜻의 형용사로, 여러분이 일하는 방식이지 여러분이 아니다.**
  - **애자일은 명사가 아니다. 애자일은 무언가를 하는 방식이다.**

- **애자일 선언에서 언급한 가치를 기억하라**
  - **공정과 도구보다 개인과 상호작용**
  - **포괄적인 문서보다 작동하는 소프트웨어**
  - **계약 협상보다 고객과의 협력**
  - **계획을 따르기보다 변화에 대응하기**
  - **왼쪽에 있는 것도 가치가 있지만 우리는 오른쪽에 있는 것에 더 높은 가치를 둔다.**

### 애자일 프로세스라는 것은 있을 수 없다

- 사실 누군가가 “이걸 하세요. 그러면 애자일인 겁니다.”라고 한다면 이건 틀린 말이다. 정의상 그렇다.
  - 애자일은 변화에 대응하는 것. 일을 시작한 이후 맞부딪히는 미지의 것에 대응하는 것이 전부이기 때문이다

### **애자일하게 일하는 방법 제안**

- **여러분이 어디에 있는지 알아내라**
- **도달하고 싶은 곳을 향하여 의미 있는 발걸음을 가능한 한 작게 옮겨라.**
- **어디에 도착했는지 평가하고, 망가트린 것이 있으면 고쳐라.**

**위 과정을 끝날 때까지 반복하라**
이런 피드백 고리를 만들고 이를 활용하라
