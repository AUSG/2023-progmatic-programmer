# 7장 코딩하는 동안

# Topic 37 파충류의 뇌에 귀 기울이기

---

- 우리는 살면서 직접적으로, 간접적으로 다양한 정보를 봤고, 무의식적으로 반영하려는 본능이 있다.

## 백지의 공포

- 새로운 프로젝트를 시작하는 일은 두렵다.
    - 본능에서 나오는 의심 때문에
    - 실수할까봐 두려워서
- 본능을 따르고, 의심은 실체가 있고 대응책을 생각할 수 있는 무엇으로 구체화 되면 나중에 고쳐라!

## 자신과 싸우기

- 코드가 읽기 쉬운날이 있는가 하면 읽기 어려운 날이 있다.
- 읽기 어려운건 코드가 무언가 말하려는 것. 구조/설계가 잘못되었을 수도 있고 엉뚱한 문제를 붙들고 있는 것일 수도 있다.

## 파충류와 이야기하는 법

> 여러분 내면의 파충류에게 귀 기울여라
> 
- 일단 하고 있는 일을 멈추고 뇌를 정리할 시간과 공간을 확보해라.
- 작성하는 코드에 대해서 그림을 그리고 동료에게 설명도 해보자.
- 프로토 타이핑을 해라

## 놀이 시간이다!

- 어떤 것을 시도해 보고 싶은 특정한 측면을 찾아보자.
- 이미 존재하는 코드 위에서 작업하고 있어서 기존 코드때문에 문제 해결이 어렵다면 비슷한 것을 프로토타이핑으로 대신 만들어라.
    1. 프로스잇에 “프로토타이핑 중”이라고 써서 모니터 옆에 붙여라
    2. 프로토타이핑은 원래 실패한다고 자신에게 상기 시켜라.
    3. 텅 빈 에디터 화면에 여러분이 배우고 싶은 것, 혹은 하고 싶은 것을 한문장의 주석으로 표현해보라
    4. 코딩을 시작하라.

## ‘여러분’의 코드뿐이 아니다.

- 다른사람의 코드를 볼 때 메모도 하고 실험도 해보고 패턴도 찾아보자.
- 틀린 것이 아니라 다른 것이다.

## 코드뿐이 아니다

- 직감을 믿고 뭔가 쎄하면 다시 돌아보자

# Topic 38 우연에 맡기는 프로그래밍

---

- 행운과 우연한 성공에 의존하는 프로그래밍을 하지 않아야 한다.

## 우연에 맡기는 프로그래밍 하기

- 제한적으로 테스트했을 때는 코드가 잘 돌아가는 것 처럼 보인다.

### 구현에서 생기는 우연

- 단순히 코드가 지금 작성된 방식이 그렇기 때문에 생기는 우연한 일들이 있다.
- 이런 우연은 결국 문서화되지 않은 에러나 예외적인 경우의 동작에 의존하게 되고 만다.
- 우연으로 잘 작동하는 코드를 굳이 건드려야하는 이유
    - 정말 제대로 돌아가는 게 아닐지도 모른다.
    - 의존하는 조건이 단지 우연인 경우도 있다.(하드웨어적)
    - 문서화되지 않은 동작은 라이브러리의 다음 릴리스에서 변경될 수도 있다.
    - 불필요한 추가 호출은 코드를 더 느리게 만든다.
    - 추가로 호출한 루틴에 새로운 버그가 생길 수도 있다.
- 다른사람이 호출할 코드를 작성하고 있을 때
    - 모듈화를 잘하는 것
    - 잘 문서화한 적은 수의 인터페이스 아래에 구현을 숨기는 것
    - 잘 정의된 계약
- 다른 루틴을 호출할 때도 문서화된 동작에만 의존하라. 모르겠으면 추측을 문서로 상세히 남겨라

### 비슷하다고 괜찮을 리는 없다.

- 딱 한시간 차이가 난다고 해서 넘기면 안된다. 전체 코드로 오염이 번질 수 있다.

### 유령 패턴

- 로그파일에 요청 1000개당 한번 꼴로 간헐적으로 발생하는 오류가 남아있다면 분석하기 어려운 경합 조건이 있을 수도 있지만 그냥 오래된 버그일 수 있다.
- 가정하지 말라, 증명하라.

### 상황에서 생기는 우연

- 특정한 상황에서 빚어지는 우연도 있다.
- 잘 되는 듯한 답을 찾는 것과 올바른 답을 찾는 것은 다르다.

> 우연에 맡기는 프로그래밍을 하지 말라.
> 

### 암묵적인 가정

- 테스트가 특히 가짜 원인과 우연한 결과로 가득 찬 영역이다.
- 가정이 개발자마다 다른 경우도 많다. 확고한 사실에 근거하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 된다.

## 의도적으로 프로그래밍하기

- 언제나 우리가 지금 무엇을 하고있는지 알아야 한다.
- 더 경험이 적은 프로그래머에게 코드를 상세히 설명할 수 있어야 한다.
- 잘 모르는 코드를 만들지 마라
- 계획을 세우고 그것을 바탕으로 진행하라
- 신뢰할 수 있는 것들에만 기대라
- 가정을 기록으로 남겨라
- 코드뿐 아니라 우리가 세운 가정도 테스트 해봐야 한다.
- 노력을 기울일 대상의 우선순위를 정하라.
- 과거의 노예가 되지 말라. 항상 리팩터링할 자세가 되어있어야 한다.

# Topic 39 알고리즘의 속도

---

## 알고리즘을 추정한다는 말의 의미

- 대부분의 알고리즘은 가변적인 입력 데이터를 다룬다.
- 반복문이나 재귀 호출을 담고있는 코드를 작성할 때면 무의식적으로 수행시간과 필요한 메모리 양을 계산한다.
- 보통 Big O 표기법을 사용한다.

## 대문자 O 표기법

![Untitled](7%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%A1%E1%86%AB%201cf2e77b79c643dc9abe851c02ab5f24/Untitled.png)

## 상식으로 추정하기

- 단순 반복문
    - 단순 반복문으로 1부터 n까지 돌아가면 O(n)
    - 소진 탐색, 배열에서 최댓값 찾기, 체크섬 생성하기
- 중첩 반복문
    - 반복문 안에 반복문이 있는 경우 O(n^2)
    - 버블 정렬
- 반씩 자르기
    - 반복문을 돌때마다 대상의 수를 반으로 줄여나가는 알고리즘인 경우 O(logN)
    - 정렬된 목록의 이진 검색, 이진 트리 탐색, 정수의 2진수 표현에서 첫번째 1인 비트를 찾는 문제
- 분할 정복
    - 입력 데이터를 둘로 나눠서 각각 독립적으로 작업한 다음, 결과를 합치는 알고리즘 O(nlogn)
    - 퀵 정렬
- 조합적
    - 순열을 다루기 시작하면 걷잡을 수 없이 들어난다.
    - 여행하는 외판원 문제, 상자에 물건을 최적으로 집어넣는 문제, 숫자 집합을 분할해서 각 부분 집합의 원소 합을 모두 같게 만드는 문제

## 실전에서의 알고리즘 속도

- 정렬같은건 그냥 라이브러리 쓰는게 최고
- 하지만 여러 반복문의 경우 얼마나 큰 숫자가 올 수 있는지 스스로에게 물어봐야한다.

> 사용하고 있는 알고리즘의 차수를 추정하라.
> 

> 여러분의 추정을 테스트하라.
> 
- 시간을 정확하게 재는게 어렵다면 ‘코드 프로파일러’를 사용해봐라

### 최고라고 언제나 최고는 아니다.

- 가장 빠른 알고리즘이 언제나 가장 좋은 알고리즘은 아니다.
    - 입력값의 규모가 작다면 단순한 삽입 정렬도 퀵 정렬과 비슷한 성능을 낸다.
- 성급한 최적화를 조심하라. 알고리즘 개선한다고 시간 투자하기 전에 그 알고리즘이 정말 병목인지 먼저 확인하는 것이 좋다.

# Topic 40 리팩터링

---

- 재구성(restructuring): 코드 고쳐쓰기, 다시 작업하기, 다시 아키텍쳐 만들기
- 리팩터링(refactoring): 밖으로 드러나는 동작은 그대로 유지한 채 내부 구조를 변경함으로써 이미 존재하는 코드를 재구성하는 체계적 기법
    1. 이 활동은 체계적이다. 아무렇게나 하는 것이 아니다.
    2. 밖으로 드러나는 동작은 바뀌지 않는다. 기능을 추가하는 작업이 아니다.
- 밖으로 드러나는 동작이 바뀌지 않는다는 것을 보장하려면 코드의 동작을 검증하는 좋은 자동화된 단위 테스트가 필요하다.

## 리팩터링은 언제 하는가?

- 중복
    - DRY 원칙 위반을 발견했다.
- 직교적이지 않은 설계
    - 더 직교적으로 바꿀 수 있는 무언가를 발견했다.
- 더 이상 유효하지 않은 지식
    - 사물은 변하고, 요구사항은 변경되며, 지금 처리하고 있는 문제에 대한 지식이 변경되었을 때
- 사용 사례
    - 진짜 사람들이 실제 상황에서 시스템을 사용하게 되었을 떄, 중요하고 필요하다고 생각했던 기능들이 그렇지 않게 되었을 때
- 테스트 통과
    - 테스트가 통과되었을 때가 다시 리팩터링 가능한 타이밍

### 현실 세계의 복잡한 문제들

- 리팩터링을 일정의 압박때문에 미루지 마라

> 일찍 리팩터링하고, 자주 리팩터링하라.
> 
- 일정에 리팩터링 시간도 포함시켜라

## 리팩터링은 어떻게 하는가?

- 리팩터링은 천천히, 신중하게, 조심스럽게 진행해야 한다.
- 리팩터링과 기능 추가를 동시에 하지 말라.
- 든든한 테스트가 있어야 리팩터링을 시작할 수 있다.
- 단계를 작게 나누어서 신중하게 작업하라.
- 탄탄한 회귀 테스트를 유지하는 것이야말로 안전한 리팩터링의 비결

# Topic 41 테스트로 코딩하기

---

> 테스트는 버그를 찾기 위한 것이 아니다.
> 

## 테스트에 대해 생각하기

- 새로운 함수를 작성하고 새로운 테스트를 진행함으로써 어떻게 사용해야할 것인지 고려하다보면 여러가지 발견을 할 수 있다.
- 예를 들어 코드의 결합도를 낮추고 유연성은 올릴 수 있었다.

## 테스트가 코딩을 주도한다.

- 우리 메서드의 테스트 작성에 대해 생각함으로써 코드의 작성자가 아니라 사용자인 것 처럼 메서드를 외부의 시선으로 보게 되었다.

> 테스트가 코드의 첫 번째 사용자다.
> 
- 무언가를 테스트하려면 그것을 이해해야만 한다.

### 테스트 주도 개발

1. 추가하고 싶은 작은 기능을 하나 결정한다.
2. 그 기능이 구현되었을 때 통과하게 될 테스트 하나 작성
3. 테스트 실행. 물론 에러가 남
4. 실패하는 테스트를 통과시킬 수 있는 최소한의 코드만 작성한다.
5. 코드를 리팩터링 한다.
- TDD 노예의 문제
    - 늘 테스트 커버리지 100%를 달성하기 위해 과도하게 많은 시간을 투자한다.
    - 많은 수의 중복 테스트가 생긴다.
    - 밑에서부터 시작해 위로 올라가는 방식으로 설계를 한다.

### 상향식 대 하향식, 그리고 여러분이 따라야하는 방식

> 상향식이나 하향식이 아니라 끝에서 끝까지 만들어라.
> 
- 점진적으로 진행하지 말고, 한쪽 끝과 다른 쪽 끝을 잇는 조그만 기능 조각들을 만들고, 그 과정에서 문제에 대하여 배워라. 코드를 채워 나가면서 배운 것을 적용하고, 각 단계마다, 고객을 참여시켜서, 전체 과정을 안내하도록 하라.

## TDD: 목표가 어디인지 알아야 한다.

- 반짝이는 테스트 통과 메시지에 홀려서 샛길로 빠질 수 있다.
- 테스트 주도로 접근하기 보다는 이런 종류의 문제를 전통적으로 어떻게 해결해왔는지에 대해 기본적인 이해를 갖추는 것으로 시작한다.
- 목표를 계속 떠올리자.

## 다시 코드로

- 소프트웨어를 만들 때 맨 처음부터 테스트가 가능하도록 만들고, 코드들을 서로 연결하기 전에 코드를 하나하나 철저하게 테스트해야만 한다.

## 단위 테스트

- 단위테스트: 어떤 모듈에게 이것저것을 시켜보는 코드
- 회귀테스트: 동일한 테스트를 코드 수정 후 다시 돌려보는 것

## 계약을 지키는지 테스트하기

- 단위테스트는 계약을 잘 지키는지 보는 테스트라고 여긴다.
    - 코드가 계약을 지키는지 여부 확인
    - 코드로 표현된 계약의 의미가 우리가 생각한 것과 일치하는지 여부

> 테스트할 수 있도록 설계하라.
> 

## 임시 테스트

- 콘솔로그같은 임시적으로 찔러보는 테스트
- 이런 테스트를 정식테스트로 만들어야한다.
- 만든 테스트 버리지말고 기존의 단위 테스트 군단에 합류 시켜라

## 테스트 접점 만들기

- 테스트를 잘 갖추어도 모든 버그를 발견할 수는 없다. → 소프트웨어를 배포한 이후에도 테스트할 일이 자주 생긴다.
- 로그 파일에 쌓이는 추적 메시지가 이런 메커니즘 가운데 하나다. 로그메시지는 규칙적이고 일관된 형식이어야 한다.
- 기능스위치를 활용해 특정 사용자나 사용자 집단에 대해 진단 메시지를 더 많이 남기도록 할 수 있다.

## 테스트 문화

- 제대로된 테스트 문화를 가져야 한다.
- 테스트 코드를 다른 제품 코드와 마찬가지로 다뤄라.

> 여러분의 소프트웨어를 테스트하라. 그러지 않으면 사용자가 테스트하게 된다.
> 

# Topic 42 속성 기반 테스트

---

## 계약, 불변식, 속성

- 계약: 선행 조건에 맞추어 입력을 넣으면 코드가 생산하는 출력이 주어진 후행 조건에 맞음을 보장
- 불변식: 함수 실행 전후로 계속 어떤 부분의 상태에 대해 참이 되는 조건
- 속성: 코드에 존재하는 계약과 불변식
- 속성 기반 테스트: 코드에서 속성을 찾아내서 테스트 자동화에 사용하는 것

> 속성 기반 테스트로 가정을 검증하라.
> 

## 테스트 데이터 생성

- 대부분의 속성 기반 테스트 라이브러리는 데이터를 어떻게 생성할지 지정하는 작은 언어가 있다.

## 잘못된 가정 찾기

- 속성 테스트를 통해 단위테스트에서 찾아낼 수 없었던 무결성을 찾아낼 수 있다.

## 속성 기반 테스트는 우리를 자주 놀래킨다.

- 속성기반 테스트가 강력한 이유는 그저 입력을 생성하는 규칙과 출력을 검증하는 단정문만 설정한 채 제멋대로 작동하도록 나두기 때문이다.
- 속성기반 테스트가 실패했다면 별도의 단위 테스트를 정식으로 추가하는 것이 좋다. 이 단위 테스트는 두 가지 역할을 한다.
    - 속성기반 테스트의 여러가지 다른 수행 결과와 상관없이 문제가 발생하는 상황에 집중할 수 있게 해준다.
    - 단위테스트가 회귀 테스트 역할을 한다.

## 속성 기반 테스트는 설계에도 도움을 준다.

- 속성기반 테스트는 여러분이 코드를 불변식과 게약이라는 관점으로 바라보게 한다.

# Topic 43 바깥에서는 안전에 주의하라

---

## 나머지 90%

- 기능을 완성한게 다가 아니라, 여기서 코드가 잘못될 수 있는 경우의 수를 찾아야 한다.
- 그리고 그 경우에 대한 단위 테스트를 추가하는 것이다.

## 기본 보안 원칙

1. 공격 표면을 최소화하라.
2. 최소 권한 원칙
3. 안전한 기본값
4. 민감 정보를 암호화하라
5. 보안 업데이트를 적용하라.

### 공격 표면을 최소화 하라

- 공격 표면: 공격자가 데이터를 입력하거나, 데이터를 추출하거나 서비스를 실행시킬 수 있는 모든 접근 지점을 합한 것이다.
- 코드의 복잡성은 공격 매개체를 유발한다.
- 입력 데이터는 공격 매개체다.
- 인증이 없는 서비스는 공격 매개체다.
- 인증을 요구하는 서비스도 공격 매개체다.
- 출력데이터는 공격 매개체이다.
- 디버깅 정보는 공격 매개체다.

> 단순함을 유지하고 공격 표면을 최소화 하라.
> 

### 최소 권한 원칙

- 최소한의 권한만을 꼭 필요한 시간만큼 제일 짧게 부여하는 것
- 권한이야말로 적을수록 좋다.

### 안전한 기본 값

- 애플리케이션 및 웹사이트 사용자의 기본 설정은 가장 안전한 값이어야 한다.

### 민감 정보를 암호화 하라

- 개인 식별 정보나 금융데이터, 비밀번호, 다른 인증 정보를 일반 텍스트로 남기지 마라.

### 보안 업데이트를 적용하라

> 보안 패치를 신속히 적용하라.
> 

## 상식 대 암호

- 암호학에 있어서 우리들의 상식이 맞지 않을 수 있다는 점을 명심해야한다.
- 암호화는 직접 만들면 안된다.

# Topic 44 이름짓기

---

## 문화를 존중하라

- 낙타 표기법이나 뱀 표기법 등 문화를 존중해라.

## 일관성

- 반드시 팀의 모든 사람이 각 단어의 뜻을 알고 일관성 있게 사용해야 한다.
- 많은 의사소통을 통해 일구어나가야 한다.
- 단어사전을 만드는 것도 중요하다.

## 이름 바꾸기는 더 어렵다.

> 이름을 잘 지어라 필요하면 이름을 바꿔라.
> 
- 이름을 부지런히 바꾸고, 이름이 바꿀수없는 상황이면 더 큰 문제이다.