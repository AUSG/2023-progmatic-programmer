# 14. 일반 텍스트의 힘

-   지식을 일반 텍스트로 저장하라.
-   단점
    -   압축된 포맷보다 더 많은 공간을 차지할 수 있음
    -   해석하고 처리하는데 더 많은 계산이 필요할 수 있음

-   구식이 되는 것에 대한 보험
    -   데이터가 암호화되어있거나, 일반 텍스트가 아니면 그것을 한 번에 이해하기 쉽지 않다.
    -   일반 텍스트를 사용한다면, 훨씬 더 오래 살아남을 것이다.
-   호환성
    -   일반 텍스트로 저장을 한다면, git과 같은 버전 관리 도구로 쉽게 관리할 수 있다.
-   더 쉬운 테스트
    -   일반 텍스트를 사용한다면, 더 쉽게 테스트 데이터를 만들고 수정할 수 있다.
-   최소 공통분모
    -   모든 참가자가 공통의 표준을 통해 사용해서 소통하도록 할 필요가 있다면, 일반 텍스트가 그 표준이다.



# 15. 조개 놀이

-   명령어 쉘의 힘을 사용하라
    -   GUI는 WYSIWYG 이라는 장점이 있지만, WYSIAYG 이라는 단점이 존재한다.
    -   명령어 쉘을 사용한다면, 생산성을 높일 수 있다.



# 16. 파워 에디팅

-   하나의 에디터를 잘 사용하라

    -   에디터 하나를 골라서 완전히 마스터하고, 모든 편집 작업에 그 에디터를 사용하라.
    -   에디터가 사용하는 모든 플랫폼에서 가능한지 확인하라.

-   에디터의 기능

    -   설정 변경 가능
    -   확장 가능
    -   프로그래밍 가능

    -   구문 강조, 자동 완성, 들여쓰기 등.. 

-   생산성

    -   확실히 메모장을 사용하는 것보다는 생산성을 올릴 수 있다.



# 17. 소스코드 관리

-   언제나 소스코드 관리 시스템을 사용하라
    -   혼자 개발할지라도, 프로토타입일지라도 소스코드 관리 시스템을 사용하라.
-   소스코드 관리와 빌드
    -   소스코드 관리를 통해 제품 빌드를 자동화하고 그것을 반복할 수 있다.
    -   빌드를 자동화함으로써 일관성을 보장할 수 있다.



# 18. 디버깅

-   디버깅시 문제의 원인 제공자를 비난하지 말고, 문제 해결이라는 관점에서 생각하라

-   디버깅을 할 때 당황하지마라. 스스로를 편안하게 하라.

-   디버깅 전략

    -   데이터를 가시화하라
        -   데이터를 시각화할 수 있는 디버거를 통해 문제 해결의 실마리 찾기
    -   트레이싱
        -   `여기까지 도달` 혹은 `x 값 = 2` 와 같은 화면 혹은 파일에 출력하는 진단용 글을 트레이싱 구문이라한다.

    -   고무오리

    -   제거 과정
        -   특정 써드파티 제품의 문제 리포트가 나오기 전에는, 그 제품의 문제라고 생각하지 말고 자신의 코드 탓을하자. ( `select` 는 망가지지 않았다.)



# 19. 텍스트 처리

-   텍스트 처리 언어 하나를 익혀라

    -   데이터 베이스 스키마 관리
    -   테스트 데이터 생성
    -   자바 속성 액세스

    -   위와 같은 작업들을 빠르고 효과적이게 할 수 있게 된다.



# 20. 코드 생성기

-   수동적 코드 생성기
    -   결과를 내기 위해 한 번만 실행된다.
    -   타이핑을 줄여주는 매개변수화된 템플릿
-   능동적 코드 생성기
    -   코드 생성이 필요할 때 마다 작동한다.
    -   어떤 지식을 단 하나의 형태로만 만들어놓고 애플리케이션이 필요로 하는 온갖 형식으로 변환할 수 있게 해주는 도구



# 21. 계약에 의한 설계

-   DBC ( Design By Contract )
    -   선행 조건
        -   루틴이 호출되기 위해 참이여야 하는 조건
    -   후행 조건
        -   루틴이 자기가 할 것이라고 보장하는 조건
    -   클래스 불변식
        -   호출자의 입장에서, 제어권이 반환되었을 때는 항상 참인 불변 조건



>   만약 호출자가 루틴의 모든 선행조건을 충족한다면, 해당 루틴은 종료시 모든 후행조건과 불변식이 참이 되는 것을 보장해야한다.

-   계약 기반으로 구현을 하면, 어떤 미래의 서브 클래스이건 우리 메서드의 의미를 변경할 수 없다고 확신할 수 있다

-   DBC 구현
    -   단정문
        -   단정문을 통해 어느 정도 흉내낼 수 있지만, 서브 타입으로 단정문을 전파할 수 없기 때문에 모든 것을 할 수는 없다.
    -   언어 지원
        -   DBC 지원하는 언어를 사용하면 된다.
-   DBC와 일찍 멈추기 ( early-return을 의미하는 듯 )
    -   DBC를 통해 구현을 하면, early return을 할 수 있다.



# 22. 죽은 프로그램은 거짓말을 하지 않는다

-   프로그램은 거짓말을 하지 않는다
-   문제를 빨리 발견하고, 빠르게 시스템을 멈출 수 있도록 해라

-   죽은 프로그램이 미치는 피해는, 절름발이 프로그램이 끼치는 피해보다는 덜하다



# 23. 단정적 프로그래밍

-   단정문을 사용하여 불가능한 상황을 예방하라.
-   단정문에는 사이드 이펙트가 존재하면 안되고, 실제 실행시에는 꺼질 수도 있다는 것을 염두에 두어야한다.
-   단정 기능을 켜두어라. 성능에 영향이 가는 단정문만 끄는 방식을 사용하자.



# 24. 언제 예외를 사용할까

-   예외는 예외적인 상황에만 사용하라.
    -   파일을 읽어오려 할 때, 그 파일이 없는게 정말 예외 상황인지 고민해보기 같은..



# 25. 리소스 사용의 균형

-   시작한 것은 끝내라
    -   리소를 할당한 루틴이, 리소스를 제거하는 역할까지 해야한다.
-   중첩 할당
    -   리소스를 할당한 순서의 반대로 해제하라.
    -   코드의 여러 곳에서 동일한 리소스 집합을 사용하는 경우, 할당 순서를 언제나 같게 하라. 데드락을 피할 수 있다.
-   객체와 예외
    -   객체 지향에서 리소를 캡슐화하면, 스코프를 벗어날 때 가비지 컬렉터가 리소를 해제한다.
-   균형과 예외
    -   예외를 함께 사용할 때, 리소스 해제를 여러번 사용하는 것은 DRY 위반.
    -   finally 구문과 같은 방식을 사용하라.
-   리소스의 균형을 늘 점검하고, 메모리가 새는지 체크하라.



# 26. 결합도 줄이기와 디미터 법칙

-   직접 객체간의 관계를 해집고 다니지 말고, 필요한 정보는 직접 물어보도록 하자.
-   디미터 법칙을 통해, 모듈관의 결합도를 최소화하라.
    -   디미터 법칙 : 객체의 모든 메서드는 , "자신", "메서드로 넘어온 인자", "자신이 생성한 객체", "직접 포함하는 객체" 의 메서드만 호출해야한다.



# 27. 메타프로그래밍

-   메타데이터를 이용하여 반환 매개 변수, 사용자 선호사항, 설치 디렉터리와 같은 애플리케이션 설정 옵션을 기술하라.
-   가능한 많은 메타데이터를 써서 애플레이케이션을 설정하고 실행시켜라
    -   코드에는 추상화를 메타데이터에는 세부 내용을 넣어, 빠르게 변화할 수 있는 유연성을 높이자.



# 28. 시간적 결합

-   동시성을 허용하고, 시간적 의존성을 줄일 필요가 있다. 이를 통해 유연성도 얻을 수 있고, 개발의 여러 측면의 의존성을 줄일 수 있다.
-   작업 흐름 분석을 통해 동시성을 개선하라
-   동시성을 고려해서 설계하면, 더 깔끔한 인터페이스를 만들 수 있다. ( ex) strtok vs StringTokenizer ) 



# 29. 단지 뷰일 뿐이야

-   객체는 자신이 필요한 이벤트들만 구독해서 받아보고, 필요하지 않은 이벤트들은 받아오지 않도록 해야한다.
-   모델에서 뷰를 분리하라.
    -   결합도를 줄이는 방식을 택하라.
    -   헥사고날 아키텍쳐와 같은 방식을 이야기하는 것 같다.



# 30. 칠판

-   칠판 시스템을 이용하면, 지식의 소비자와 생산자들이 익명으로 그리고 비동ㅈ기적으로 데이터를 주고 받는 공간이 생긴다.
    -   이를 통해 객체 사이의 결합도도 줄일 수 있다.
-   칠판을 이용하여 작업의 흐름을 조율하라
